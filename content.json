{"meta":{"title":"我是王文徽","subtitle":"我相信皮格马利翁效应","description":"王文徽,个人博客,记录","author":"Bbxren","url":"http://bbxren.site","root":"/"},"pages":[{"title":"分类","date":"2020-01-18T14:13:08.187Z","updated":"2020-01-18T14:13:08.187Z","comments":false,"path":"categories/index.html","permalink":"http://bbxren.site/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-06-01T08:03:41.653Z","updated":"2020-01-18T14:13:08.191Z","comments":true,"path":"link/index.html","permalink":"http://bbxren.site/link/index.html","excerpt":"","text":""},{"title":"DESIGN","date":"2020-01-21T15:48:03.536Z","updated":"2020-01-18T14:13:08.189Z","comments":false,"path":"gallery/index.html","permalink":"http://bbxren.site/gallery/index.html","excerpt":"","text":"个人设计作品集"},{"title":"movies","date":"2019-12-16T10:13:56.000Z","updated":"2020-01-18T14:13:08.192Z","comments":true,"path":"movies/index.html","permalink":"http://bbxren.site/movies/index.html","excerpt":"","text":"以下为测试视频，具体页面尚在开发中…以后有空再说…(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\",\"pic\":\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1576503253580&di=b75f807b0d09d21b17685939aa779c5f&imgtype=0&src=http%3A%2F%2Fa.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2F838ba61ea8d3fd1fa9a85cbd304e251f94ca5f90.jpg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()"},{"title":"music","date":"2019-12-16T10:13:34.000Z","updated":"2020-01-18T14:13:08.193Z","comments":false,"path":"music/index.html","permalink":"http://bbxren.site/music/index.html","excerpt":"","text":"以下为测试页面音乐，具体页面尚在开发中…以后有空再说…"},{"title":"标签","date":"2020-01-18T14:13:08.194Z","updated":"2020-01-18T14:13:08.194Z","comments":false,"path":"tags/index.html","permalink":"http://bbxren.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"二分查找","slug":"二分法","date":"2020-01-20T11:49:04.000Z","updated":"2020-01-21T14:33:03.774Z","comments":true,"path":"2020/01/20/算法/二分法/","link":"","permalink":"http://bbxren.site/2020/01/20/算法/二分法/","excerpt":"","text":"二分查找比如你要查一个以P打头的通讯录用户，或者R开头的单词，都更适合从中间查找，这种算法就是二分查找。其输入是一个有序的元素列表，查找元素包含在列表中，返回该位置，否则返回null。如果列表包含100个元素，简单查找最多需要100次，二分查找最多只需要7次；如果列表包含40亿个数字，二分查找最多只需要32次，即运行时间为对数时间（log时间）。 大O表示法指出了算法的速度一些常见的大O运行时间： O(log n)，也叫对数时间，这样的算法包括二分查找。 O(n)，也叫线性时间，这样的算法包括简单查找。 O(n * log n)，这样的算法包括快速排序。 O(n²)，选择排序，速度较慢。 O(n!)，例如旅行商问题。简明代码123456789101112int BinarySearch(int len[],int target,int low,int high)while(low &lt;= high)&#123; int mid = low + (high-low) / 2; if (target == len[mid])&#123; return mid; else if (target &lt; len[mid]) high = mid - 1; else low = mid + 1; &#125; return null;&#125; 二分法思想简单，数据量大时算法加速提升速度快，要求待查数据已被整理为有序列表。 注意问题 数据范围：整型范围为-2³¹～2³¹-1，二分查找时如果使用int mid = (high + low) / 2;对于较大的low和high可能相加后超过范围，因此使用int mid = low + (high-low) / 2; 边界确定。边界确定关系到二分查找算法的赋值与判断。如high &gt; low还是high &gt;= low，high = mid还是 high = mid - 1还有high的初值是n还是n-1(n指元素个数)，一旦错误，会导致死循环或者返回错误的情况，应该保持统一的开闭区间，比如high初值为n时，是左闭右开区间[low,high),取子序列也应该是左闭右开区间，while( low&lt; high)，以及high = mid;,子区间序列为[low,mid)，当high初始值为n-1，则与示例代码相同，子区间为[low,mid-1]。3.二分查找的变形，现实问题大多是二分查找的变形，不会是简单的基础模型，例如查找重复出现的元素第一次/最后一次出现的位置，返回小于（大于）或等于目标元素的最大（小）元素等，针对不同问题修改相应的判断和赋值语句，需要注意以下几点： 注意high和low的赋值，保证目标元素必然不在排除序列中。 每次二分过程注意low和high的赋值和循环条件判断，保证不会出现死循环，即要么排除元素序列减少，要么结束循环。 退出循环时，分析此时目标元素形态，确定返回位置的正确表达形式。例题方程求解（POJ 4140）问题描述求下面方程的根：f(x) = x³- 5x²+ 10x - 80 = 0。输出要求精确到小数点后9位。输出样例5.705085930 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;math.h&gt;double BinarySearch(double low, double high) &#123; double mid; double f; while (high - low &gt; 0.00000000001) //精度 &#123; mid = low + (high - low) / 2; f = mid * mid * mid - 5 * mid * mid + 10 * mid - 80; if (f &lt; 0) low = mid; else high = mid; &#125; return mid;&#125;int main()&#123; printf(\"%.9lf\\n\",BinarySearch(0.0,10.0)); return 0;&#125; 在线翻译（POJ 2530）问题描述You have just moved from Waterloo to a big city. The people here speak an incomprehensible dialect of a foreign language. Fortunately, you have a dictionary to help you understand them.输入Input consists of up to 100,000 dictionary entries, followed by a blank line, followed by a message of up to 100,000 words. Each dictionary entry is a line containing an English word, followed by a space and a foreign language word. No foreign word appears more than once in the dictionary. The message is a sequence of words in the foreign language, one word on each line. Each word in the input is a sequence of at most 10 lowercase letters.输出要求Output is the message translated to English, one word per line. Foreign words not in the dictionary should be translated as “eh”.样例输入dog ogdaycat atcaypig igpayfroot ootfrayloops oopslay atcayittenkayoopslay样例输出catehloops 思路由于查找量大，最多可能有100000个，故采用二分法查找词条，这里要注意的是查找的内容为字符串，定义cmp()函数进行排序（sort函数的排序规则），字符串大小比较要用到strcmp()函数，strcmp(a,b)返回小于0的值表示a&lt;b。还要注意输入格式的问题，即如何准确发现空行，可以使用cin.peek()探查输入流的下一个字符。若为换行，结束输入，转入翻译阶段，同时使用cin.peek()前要使用cin.get()处理掉行末换行符,同时排序部分用到了algorithm标准函数库里的sort函数，从网上了解到，sort函数使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)，执行效率较高！有关sort函数的用法，我参考了这篇文章sort函数有三个参数：（1）第一个是要排序的数组的起始地址。（2）第二个是结束的地址（最后一位要排序的地址）（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。Sort函数使用模板:Sort(start,end,排序方法)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;struct Entry &#123; char english[11]; char foreign[11];&#125;entries[100005];int Cmp(Entry entry1,Entry entry2) &#123; return strcmp(entry1.foreign, entry2.foreign) &lt; 0; //将字典里的foreign从小到大排列&#125;int main()&#123; int num = 0; char target[11]; while (true) &#123; scanf(\"%s%s\", entries[num].english,entries[num].foreign); num++; cin.get(); if (cin.peek() == '\\n')break; &#125; sort(entries, entries + num, Cmp); while (scanf(\"%s\",target) != EOF) &#123; int low = 0; int n = 0; int high = num; while (low &lt; high) &#123; int mid = low + (high + low) / 2; n = strcmp(entries[mid].foreign, target); if (n &lt; 0) low = mid; else if (n &gt; 0) high = mid; else &#123; printf(\"%s\\n\", entries[mid].english); break; &#125; &#125; if(n)printf(\"en\\n\"); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://bbxren.site/categories/算法/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://bbxren.site/tags/Algorithm/"}]},{"title":"给博客通过CDN实现访问加速？——Cloudflare","slug":"给博客通过CDN实现访问加速？——Cloudflare","date":"2019-12-31T15:26:18.000Z","updated":"2020-06-24T09:12:43.493Z","comments":true,"path":"2019/12/31/博客/给博客通过CDN实现访问加速？——Cloudflare/","link":"","permalink":"http://bbxren.site/2019/12/31/博客/给博客通过CDN实现访问加速？——Cloudflare/","excerpt":"","text":"给博客通过CDN实现访问加速？——CloudflareCDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。就跟物流中心一样，哪里离你近就给你从哪发货。 Cloudflare 以向客户提供网站安全管理、性能优化及相关的技术支持为主要业务。提供包括CDN、优化工具、安全、分析以及应用等服务。并且与百度有合作，国内部署有大量的节点，以及处理 GitHub Pages 的问题。 注册账号 注册好后点击 Add site添加域名 这里我遇到了提示域名未注册的问题导致无法添加，经过测试是DNS解析的问题，我把记录值从域名变成A类型的IP地址得以解决 等待解析完成后continue 然后他会让你修改DNS服务器，我的是阿里云域名控制台，阿里云的DNS服务器修改如图，修改完成，等待一段时间后生效。bbxren.site is now queued up to be re-checked. Please check back in a few hours. You’ll also be notified by email once your site becomes active. 你也可以通过WHOIS查看自己的网站信息判断是否修改成功。 （不过这个方案可能GG了） whois之后我又发现好像这两篇文章的博主并没有用Cloudflare（？？？），另一个使用了的速度和gitpages没什么区别（可能是因为内陆节点的问题），不过解决了百度抓取的问题，还有考虑到浏览器缓存问题，等我的DNS服务器check完后会再进一步测试，至于部署到coding，gitee等其他方案等因为不稳定原因直接pass了，可能会考虑jsDelivr或者备案后打包到七牛吧。 还有就是hexo的编译速度可能会出现变慢的情况，后续（审美疲劳）的时候会考虑换成Hugo，据说是目前世界第一快的（滑稽），由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 然后最近会解决考虑安全性下多台电脑和手机编写博客的问题。 参考文章1 参考文章2 使用了cloudflare的博客","categories":[{"name":"博客","slug":"博客","permalink":"http://bbxren.site/categories/博客/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://bbxren.site/tags/CDN/"}]}]}